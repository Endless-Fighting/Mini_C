# 关于mini-C词法分析器的实现
###### 作者：武汉大学-计算机学院-黎冠延
###### 2018.9.23
----
## 实现思想
1. 通过开头字符找到相应的分析函数，通过分析函数进行内容分析，分析函数会移动扫描指针
2. 每个分析函数都会移动当前扫描指针，且函数结束的时候永远都是指向下一个要分析的字符
3. 所有分析函数的函数原型都为：
  bool (\*)(const char \*, size_t&, const size_t, vector<token_t> &)
  <br />
  返回值表示当前函数是否已经移动指针，即是否完成本轮分析。
4. 如果完成本轮的分析则跳到开头，如果都没有进行分析则说明是一个不合法的字符，报错。

### 总体实现思路可以改进的地方
1. 因为要同时照顾calculator的词法分析，可以考虑将实现的分析器分成两个，每个分析器拥有自己的分析函数array/set/map
2. 分析器内部可以通过一个unordered_map进行函数分析，则不需要逐个扫描
3. 建立在 2. 的基础上返回值可以直接返回exception的内容，进一步提高效率，不需要throw和catch

## 分析函数内部实现细节
1. word相对其他几个比较简单，就是扫描连续字符，直到不存在继续连续的可能，然后扫描keywords表，如果存在则表示为相应的keywords，需要注意的是，如果是true或者false则需要变为数值类型存储。如果不存在于keywords表中则表示为identifier。
2. 符号的分析分为三类：<BR />

- 1) 符号后面跟着别的符号可以表示不同的意思，如：->, +=, ++ 等。<br />
    这类的实现过程是：建立一个后续符号集合，即后文可以跟随的符号，如>, =, +等，如果连续遇到可以跟随的符号都加入临时符号，然后如果临时符号不在keywords中，则逐个向前削减，直到拿到最长的在keywords中的符号为止。<BR />
- 2) 符号本身必然代表自己，即这类符号后面跟不同的符号不能表示别的意思，如：(, ), {, } 等。
    这类符号的处理过程就是直接加入自身即可。
- 3) -号：这个符号可以和数字表示负数，和别的符号都不同。所以，如果满足：后面直接跟着数字（可以隔着分隔符），同时，上一个符号的情况允许，则可以表示负数的一部分。如果不是则像普通符号一样进行处理。<BR />
    如果表示负数直接放到数字分析中，否则手动实现一个负号的分析。

3. char 和 string 的分析。这两者明显是分别遇到单引号（'）或者双引号（"）的时候进行处理。处理的难点是遇到转义符。<BR />
  转义符支持的是\\nnn（代表八进制指定字符）, \\xNN（代表十六进制指定字符）和其他几个标准中定义的转义字符。<BR />
  同时需要注意的是如果遇到了没有定义的转义字符，如\\c则直接忽略\\而表示自身，即c。
4. 数字的处理，这类的处理最为复杂，但是逻辑关系不算太复杂。思想是进入不同的轨道来进行分析。<BR />

- 首先根据前缀分清楚十六进制还是十进制的轨道。
   -  十六进制轨道不允许别的轨道的存在，而且只允许u32。
   - 十进制轨道默认处理i32，如果遇到./e/E则进入小数处理轨道，并立刻结束本轨道计算。
     - 小数处理轨道默认进行f32的分析，如果遇到e/E则进入f64出离轨道，并立即结束本轨道计算。
       - f64轨道的计算直接计算e/E的右手边的数字。
